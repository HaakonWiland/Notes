
---
tags:
- #Cryptography 
- #TTM4135

--- 
Definitions: 
- **Confidentiality:** Prevent unauthorised disclosure of information.
- **Integrity:** Prevent unauthorised modification of informaton.
- **Availability:** Ensuring resources are accessibe when required by an authorised user. 
- **Entity Authentication:** Process by which one entity is assured of the identity of a secound entity.
- **Non-repudiation:** Proof of the origin, authenticity and integrity of the data. 
- **Group generator:** An element of a group that through repeated application of the group operation, can generate the entire group.  
- **Finite field:** A group with addition and multiplication, and with prop. *Finite cadinality*, and *Characteristic*.
- **symmetric and asymmetric ciphers:** Symmetric ciphers uses the same key for encryption and decryption, while asymmetric used two keys, one for each operation.  
- **Ciphertext only attack:** Attacker have access to only a set of ciphertexts, that is, no information about the plaintext generating the cipherstexts. 
- **Known plaintext attack:** Attacker has info about ciphertext and the plaintext generating them. 
- **Chosen plaintext attack:** Attacker knows some the ciphertext of his own chosen plaintexts. 
- **Chosen ciphertext attack:** Attacker can take arbitrary ciphertexts, and find the corresponding plaintext. 
- **Kerckhoffs principle:** Security of the cryptosystem myst lie in the choice of its keys only, everything else should be considered public knowledge. 
- **Passive attacks:** Attack that attempts to learn/make use of, the information from a system. Examples: **Release of message**, **Traffic analysis**.
- **Active attacks:** Attack that attempts to alter system resources / affect their operation. Examples: **Replay, Data modification, Masquerade, Denial of service**
- **Confusion:** Substitution to make the relationship between the key and ciphertext as complex as possible. 
- **Diffusion:** Transformations that dissipate the statistical properties of the plaintext across the ciphertext. 
- **Differental cryptoanalysis:** Attack based on difference between two input plaintexts that can be correlated to differences in their ciphertext. 

### **Basic encryption:**
- **Caesar cipher:**
- **Random Substitution cipher:**
- **Polyalphabetic substitution:** Sub. cipher using multiple mappings, hence smooth the frequency distribution. 
![[Pasted image 20240205140251.png]]

- Vigenere cipher: Type of periodic substitution cipher. Choosing a key of length d, for each letter in the key take the plaintext letter sum it with the key letter mod n(where n is the length of alphabet). 
![[Pasted image 20240205140653.png]]

### **Hill cipher:**

- TYPE: Polygraphic cipher
- Weakness: Linear -> plaintext attacks easy.
- Breaking: Knowing bits of the plaintext and d, lets us solve equation for k and k-inverse. 

![[Pasted image 20240205141307.png]]

Splitting up out plaintext into bits of d-characters, that is, write each plaintextblock as column vectors in the dxd matrix. If there is insufficient letters to fill a block we use padding, preferably with uncommon letters. 


### **Steam cipher:**

- TYPE: Symmetric key cipher, 
- Requirements: Keystream need good randomness properties 
- Different versions: Synchronous S.C , Self-Synchronizing S.C

Starting of the algorithm converts the plaintext to digits. Then generates a pseudo-random key stream, generated by an internal secret key. Then successively, preforming a bitwise operation(XOR, OR) of each keystream-digit and plaintext digit.   

The stream cipher operate on continuous stream of data(unlike the block cipher which work on fixed size blocks).

![[Pasted image 20240205144412.png]]


### **One-time-pad:**
- Attributes: PERFECT SECRECY 
- Requirements: Key is >= length of message, Key is onetime use and truly random
- Weakness: Message only as long as the key, can only use each letter once in the message, key-transportation(length of key >= length of message).

![[Pasted image 20240205144550.png]]


Can also use binary one time pad:
![[Pasted image 20240205145142.png]]

### **Block cipher:**

- TYPE: Symmetric key cipher 

Plaintext split up in blocks of fixed size, and each block is encrypted with the same key. Block size is typically 64 bits or 256 bits.   

**Techniques used within block ciphers:**

**Product cipher:** Cryptosystem in which the encryption function is formed by applying several sub-encryption functions. 

**Iterated ciphers:** 

Encryption process is divided into r similar rounds, and all sub-encryption functions are all the same function, g,  called the round function. Then from a master key, K, we derive the round keys ,Ki. (We find the round keys using key schedule). 

Encrypting with iterated ciphers:
![[Pasted image 20240205150941.png]]

Decrypting with iterated ciphers: 
![[Pasted image 20240205151022.png]]


We categorize iterated ciphers into two types:

**Feistel Ciphers(Feistel Network):** Example DES
- Attributes: Works for any round function(since we never invert it) and any number of rounds. 
- Requirements: Round function is the only non-linear part of system, so need to be picked correctly. 


In the Feistel cipher, the round function swaps the two halves of the block and forms a new right hand half.  

Video for explanation: https://www.youtube.com/watch?v=FGhj3CGxl8I

![[Pasted image 20240205152921.png]]

To decrypt, we reverse the the order of traverse the "feistel ladder", applying the last key first.   

**Substitution-Permutation Networks (SPN):** Example AES
- Requirements: Block length n must allow each block to be split into m sub-blocks of length l: n = l * m. 


Key scheduling: Masterkey (K) is split into multiple roundkeys (Ki)

1. The plaintext is XOR'ed with the first roundkey K0. 
2. Then we split the result into a number of S-boxes(bits we send it is **substituted** with another set of bits, often based on a lookup table). This possess introduces non-linearity to the system.  
3. Then the result of step 2 is send as input into a P-box, which rearrange the order of bits. This permutation of the bits is fixed for each round of the SPN. 
4. The result of step 3 is then XOR'ed with the next key round K1
5. Then we repeat step 1-4 again a number of times, the final result we call the ciphertext.  
![[Pasted image 20240213125718.png]]

Video explanation: https://www.youtube.com/watch?v=DLjzI5dX8jc


#### Data Encryption Standard (DES):
- TYPE: 16-round Feistel cipher.
- Key length: 56 Bits
- Data block length: 64 Bits. 

Step by step Encryption:

1. The 64 bit length data block is permutated  by an initial fixed permutation IP  
2. The permutated data block then undergo a 16 round Feistel operation.
		2.1. The RIGHT HAND 32bit datablock is expaned into 48 bits(based of a predefined table), then XOR'ed with a 48 bit roundkey. We derive the 48 bit roundkey from the 56 bit masterkey. This is done buy splitting 56 bits into 2 x 28 bit halvs, which then is shifted and compressed to make a 48 bit roundkey.   (NOTE. that each roundkey is different).
		2.2: The result of 2.1 is split into 8 s-boxes(6 bits into each box) S1-S8, and substitute them (based on predefined table) for 4 new bits that each box send out. 
		2.3 The 8 boxes with 4 bits each is then sent into a permutation box P, which rearrange the bits (Fixed permutation).
		2.4 The result of 2.3 is then XOR'ed with the 32 bit LEFT HAND original datablock.
		2.5 The original RIGHT HAND side of the of the datablock becomes the left hand side of the next round, and our result 2.4 is the new right hand side. 
		THIS IS REPEATED 16 TIMES.  
		![[Pasted image 20240213133450.png]]

		
3. After the Feistel operation we apply a final permutation IP^-1. This effectively "undoes" the initial permutation. This makes it into a format that is easy to decrypt given the correct key. 

We often refer the process of going through the S - and P-boxes in step 2.2 and 2.3 as the encryption function f. 

Versions: 
- Double:
- Triple: 

Possible attacks:
- Requirements: 
- Brute force: 

#### Advance Encryption Standard (AES):
- TYPE: symmetric key block cipher, BYTE based design
- Data block length: 128 bits
- Key length: 128 , 192 , 256 bits. More bits -> More rounds (10), (12) ,(14)-> More secure. 
- Data block size: 16 bytes (16 * 8 = 128). Think of it as a 4x4 grid, where each entry is a byte (8 bits).
![[Pasted image 20240213175858.png]]




Step by step Encryption:
1. Plaintext of 128 bits XOR'ed with the first round key K1. 
2. SUB BYTES: Each byte in the data block is substituted with another byte from a s-box.
3. SHIFT ROWS: Each byte is shifted cyclically to the left: first row not shifted, second round shifted one to left, and so on. 
4. MIX COLUMNS: For each column in the matrix, mix up the entries within the columns. Done by taking each the columns and "multiplied" with a fixed matrix. Lookup GL(2^8) for the details.  
5. ADD ROUND KEY: After step 4, we take that state XOR'ed with the round key. 

The steps 1-5 is repeated round_number amount of times. Note the last round we do not mix the columns, this is just to simplify decryption.  

Decryption:
Doing the same operations just backwards, staring with the last round key etc. (Fill in more).

Video explanation: https://www.youtube.com/watch?v=O4xNJsjtN6E

Check up cryptools visualization. 

### Modes of Operation:
If we would like to apply a cipher to a larger amount of data, say, AES to some data that is >128bits, then we would have to split up the data, and apply AES to each part. The techniques used to split the data, apply the cipher to each part, then combining it to derive the final cipher is what we call **Modes of operation.** 

We need these modes of operation because this process can be insecure.

Terminology: 
- Initialization vector (IV): starts the encryption process before encrypting the first plaintext block. This will result in a plaintext being encrypted with the same key, will result in a different cipher when the IV is different for each time we encrypt. 
- Keystream: sequence of pseudorandom bits/bytes generated by a steam cipher. We use the keystream with (XOR) the plaintext to make the cipher. 


Different purpose:
- Provide confidentiality -> Often done by introducing randomization.
- Integrity -> often by Authentication 

Mods can also have different features for practial reasons:
- Parallel processing: multiple plaintexts etc.
- Error propagation: Bit errors result in multiple bit errors -> Easier to detect modifications 
- Padding: To complete blocks, is added before encryption, and removed when decryption. 

**Some standard modes from NIST:** 
![[Pasted image 20240214112111.png]]

**Electronic Code book(ECB):**
![[Pasted image 20240214112650.png]]

![[Pasted image 20240214112717.png]]

![[Pasted image 20240214112749.png]]


**Cipher block chaining (CBC):**
![[Pasted image 20240214113652.png]]
![[Pasted image 20240214113703.png]]
![[Pasted image 20240214113809.png]]'


**Counter (CTR) mode:** Mode of operation that turns a block cipher into a stream cipher. 

TYPE: Synchronous stream cipher.
![[Pasted image 20240214115618.png]]
![[Pasted image 20240214115629.png]]
![[Pasted image 20240214115642.png]]
![[Pasted image 20240214115736.png]]

### Random Numbers:

Hard to define what a random string of bits is, we more often think of THE WAY a bit of string is GENERATED as being random or not.

True random number generator (TRNG): Physical process which outputs each valid string independently with equal probability.

Pseudo random number generator (PRNG):  Deterministic algorithm which approximates a TRNG. 

Terminology: 
- Deterministic: Gives the same output each time, given that we use the same key/IV/nonce etc.

Often we use a TRNG as seed for a PRNG. 

Entropy Sources for random bit generation: https://csrc.nist.gov/pubs/sp/800/90/b/final
-> Give examples where we can find physical sources for true randomness, and how to validate them. 

**Deterministic Random Bit Generators (DRBG)**: (Fill inn later)

Functions:
- Instantiate:
- Generate:
- Reseed:
- Test:
- Uninstantiate: 

Properties of secure DRBG:
- Backtrack risistance:
- Forward prediction resistance: 

Examples:

**CTR_DRBG:**


**Dual_EC_DRBG:**


More:
Specific DRBG algorithms: https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final 

### Hash functions:

**Uses of hash functions:**
Note:
- Hash != encryption 
- Hash does not depend on a key
- Not possible to go backwards to find the input. 

General: 
- Helping authentication: 
-> Authenticate the hash of a message to authenticate message 
-> Building block for message authentication codes(HMAC)
-> Building block for signatures. 

Terminology:
- Compression function: Takes two n-bit input strings x1 and x2 and produces an n-bit output string y. 

Definition: Public function with properties: 
1. It is simple and fast to compute
2. It takes in a message of arbitrary length, and returns a result of fixed length.

![[Pasted image 20240214124446.png]]

**Birthday paradox:**
General: if we choose around √M values from a set of size M, the probability of getting two values the same is around 0.5. -> This gives us a general rule of thumb for how many different elements in the images of a given hash function that should exist. We base this of how many hashed a computer is able of guess.

**Iterated Hash functions:** As with the different modes of operation used to split data into multiple parts, that then is used as input to a cipher, we can do the same with hashes. 

-> Iterated hashes split the input into blocks of fixed size and operate on each block sequentially using a function. 

**Merkle-Damgård construction:** 
1. Break message m into n-bit blocks m1 , m2 , .... ml.
2. Add padding and encoding of the length of m (may or may not add one block)
3. Input each block into compression function h along with chained output(Use an IV to start)

![[Pasted image 20240214131621.png]]

Note: If compression function h is collision-resistant, then hash function h is collision-resistant. (CHECK UP PROOF)

Possible weaknesses:
- Length extension attack: Once you have one collision -> easy to find more.
- Second-preimage attacks: Generally not as hard as they should be. 

Hash functions using M-D Construction: MD5, SHA-1, SHA-2-family. 

MDx: Not secure in 2024
SHA-0 , SHA-1: 
- 160 bit output
- SHA-0 broken 2004
- SHA-1 First collison in 2017

SHA-2 family:
![[Pasted image 20240214132558.png]]

Sometimes we write hash function as taking in keys, but note that it must be hard to find a collision for a randomly generated key s and the keys is not kept secret. 
![[Pasted image 20240214133446.png]]


**Storing passwords for login:**
- Usually store the hash with some salt, and not the password: h = H(password, salt), and store (salt,h) in the database. 
- Its then easy to check the password that a user types, and compare it against the hash and salt. 
- Hard for an attacker for to recover password from the hash, since it is preimage resistant. 
- Also, attacker needs to store different salts for each dictionary attack. 

### MAC and authenticated encryption:

Mechanism used for message integrity and authentication. 

Concept:
Both sender and receiver have the secret key K(Symmetric key), and access to a MAC algorithm which outputs a tag of fixed length. The sender sends the pair (M,T), a message M of arbitrary length, with the tag T. Then the recipient needs to recompute the tag based on M, and check the he gets the same Tag output T. 

Formula: MAC(M,K) = T 

MAC PROPERTIES:
- Unforgeability: Impossible to find tag T without knowing key K.
- #TODO

While hiding messages is important, we also want to develop integrity in the communication. e.i. Ensuring that the message came from the correct person and that the message is not modified. 

HMAC:
TYPE: Iterated cryptographic hash function 
USES: Standardized in applications such as TLS and IPsec 

Construction:
![[Pasted image 20240224132544.png]]

Combining encryption and message authentication: #TODO

Authenticated encryption with associated data(AEAD): #TODO 
Galois Counter Mode(GCM):


### Number Theory for public key cryptography:


### Public key cryptography 


### RSA:


### Digital Signatures:


### Key Establishment and Certificates:

