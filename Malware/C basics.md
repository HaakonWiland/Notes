#programming 

**Compile self-contained .exe file:**
g++ -o keylogger.exe keylogger.cpp -static

```c
int main(int argc, char *argv[]) 
```
**argc: Argument count**, command line argument counter that needs to be at least 1
**argc[]: Argument vector**, of the type "array of c strings", ``argv[0]`` is the first element and is the name of the program as it was invoked. 


**Pointer to pointer dereferencing approach:**  from Dolphin. 
The pointer-to-pointer dereferencing approach (`*(type **)address`) is often used in cases
where you need to access or modify the data that a pointer is pointing to within a
function. This can be especially useful when dealing with dynamically allocated memory,
such as arrays or structures, or when working with complex data types that require
multiple levels of indirection (e.g., double pointers).

Here are some examples of using this approach in C/C++:

1. Accessing a structure member through a pointer to a pointer:
```c++
typedef struct {
    int x;
    int y;
} Point;

void modify_coordinate(Point **point, int new_x) {
    (*point)->x = new_x;
}

int main() {
    Point *p = new Point;
    p->x = 10;
    p->y = 20;

    modify_coordinate(&p, 50); // Modify the x-coordinate of the point

    delete p;
    return 0;
}
```
In this example, we use a pointer to a pointer (`Point **point`) to access and modify the
`x` member of the `Point` structure. Inside the `modify_coordinate()` function, we use the
pointer-to-pointer dereferencing approach (`(*point)->x = new_x;`) to access the `x`
member and update its value.

2. Accessing an array element through a pointer to a pointer:
```c++
void swap_elements(int **arr, int i, int j) {
    int temp = (*arr)[i]; // Get the value at index i
    (*arr)[i] = (*arr)[j]; // Store the value at index j in index i
    (*arr)[j] = temp; // Store the original value of index i in index j
}

int main() {
    int n = 5;
    int *arr = new int[n];
    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;
    arr[3] = 40;
    arr[4] = 50;

    swap_elements(&arr, 0, 3); // Swap elements at index 0 and index 3 in the array

    delete[] arr;
    return 0;
}
```
In this example, we use a pointer to a pointer (`int **arr`) to access and modify elements
of an integer array. Inside the `swap_elements()` function, we use the pointer-to-pointer
dereferencing approach (`(*arr)[i] = ...;`) to access individual elements of the array
using indexing (`[i]`).

In general, you can use this pointer-to-pointer dereferencing approach when working with
complex data types or dynamic memory allocation, where multiple levels of indirection are
required. However, for simple cases and basic data types, you can use normal pointer
dereferencing (`(*p)`) to access the data that a pointer is pointing to.

**Mutex**:
header: mutex.h
source: https://en.cppreference.com/w/cpp/thread/mutex 
purpose: protect data within a thread, prevent data races and ensure thread safety in a multithreaded environment. e.i. only one thread can use the resource within a block of code.   

example:  

```c
//Here everything after std::lock_guard<std::mutex> guard(bufferMutex); can only be accessed by the current thread. 

std::lock_guard<std::mutex> guard(bufferMutex);
outFile << keystrokeBuffer;
keystrokeBuffer.clear();
```


**Good to know functions:**
- sizeof(): return size of a buffer (arrray of char) in BYTES. 