
**Current state of the program and relevant questions:** 
1. **Glitch with program stopping:** ALTGR + 5 = € -> Make the program stop running. 
2. **Optional**: VK mapping to work representation of VK. 
3. **Socket programming and sending live keystrokes between kali and LAB.**


- Small and big letters split apart with virtual key code of shift and caps lock appearing before a letter.  
- Works in other applications as well outside of the editor. 
- Backspace appear as:  Weird red box  
- Currently do not add enter with new line unless the user presses it. Does not need to be a problem?
- What to do with special characters like: ÆØÅ? currently just spams a question mark. 
- Where to save the .txt file? -> it should be hidden somewhere in the targets system, and then sent to the KALI after a while.  Can stream real time? 
- How to deploy and hide the program? -> how to handle windows defender and anti virus? 
- Handle mice inputs? 
- Repeted key inputs, example backspace: Find a way to handle-> If more that 3 inputs of the same key, do not log more of them? 
- Adding handle to foreground window, the window the user is typing in: GetForegroundWindow().


**Characters it can not log currently:**
- Æ, Ø, Å 
- §, ¤, £
- TAB and ENTER looks similar, might want to print it out explicitly. 
- Red-box-notation: Backspace, ESC




Example of existing RATs: NjRAT, Blackshades.

Potential Functionalities:
- **Remote shell:**
- **Allow file transfer** between attacker(KALI VM) and the target windows VM. Both download and upload. Can be over FTP, HTTP, or TCP(prop a bit more work).
- **Screen capture:** Livestreaming the screen of the target, can be done with windows API such as BitBlt(), GetWindowsRect(), GetForegroundWindow(), ....
- Keyboard and mouse control: Attacker can send keystrokes and control mouse cursor on target system remote. 
- Anti-detection features:  rootkit? -> persistent across reboot 
- Network proxy: Attacker can route traffic through infected target and hide their IP.

Networking in the Oracle Lab: KALI, Lab and Target need to talk to each other. 
- Can do **Bridget networking**: VMs unique IPs and allows them to communicate directly with the host computer network interface. 
- Can do **NAT networking**: Private IP addresses to the VMs and routes traffic through a shared virtual network adapter on the host machine.  
- May need to modify firewall settings on each VM to allow desired communication. 

General: 
- Think about what can happen if something spread to the Host computer.
- Time sync. between the VMs can use useful to prevent bugs. Use ntpdate(KALI) og w32tm / resync (Windows).
- Use snapshots of VMs when deploying malware.
- Problems with executing such program in Windows 10? Does defender block such execution? 


#### Keylogger: 

There are different categories of keylogger. Our version falls in the API-Based category.

Save all keystrokes made on a system and save them in a nicely formatted matter in a .txt file with date. It is designed to work in Windows, and by nature is not cross platform. When we have managed to save normal keystrokes, we need to encrypt the content of the .txt file containing the key logs. 

C++ vs PowerShell: C++ preforms better, and has better control over system resources. But PowerShell is a bit "simpler" to develop. Since I have more experience with C++, I clearly preferer to use it over PS:   

**Research:**
- Different ways we can capture keyboard input on windows. 
- Event handling: Register and handle global keyboard events using Windows API, may need to use low-level keyboard hooks (?), SetWindowsHookEx() or RegisterRawInputDevices(). 
- Data structure for saving keystrokes to file:  Asynchronous I/O operation WriteFile()? Better to write to file in large chunks, helps reduce number of times I/O functions is called. 
- Error handling: What to do if the program faile to read a keystroke? What happens when the user turns of the system? -> If program cannot record the keystroke, have expiation handling. 
- Getting around security features in Windows 10: Sign the executable with valid code-signing certification to prove it is legit. Can help bypass SmartScreen Warnings when user try to run it. Other: Can use packaging tool, more? 
![[Pasted image 20240530164344.png]]
- Hookchains: The callback function in SetWindowsHookEx() returns a call to CallNextHookEx(). Not sure how this works, or why we care. -> functionality gets broken? Basically, since we are intercepting the keystrokes as raw data before any other part of the system, not calling the next hook, may result in other parts of the system to not get access to the keyinput. Returning CallNextHookEx() ensures normal functionality. 


Global keyboard events: We need to capture all keystrokes that happen on the computer, even if the target user is not interacting with any specific program or interface. To be able to do this, we need  **Hooks**.

Hooks: lets us intercept raw keyboard input data before it is processed by the operating system or any other application. Ensures that we are capturing ALL keyboard events 

**From ollama-dolphin:**

Here's an example of how you can use the `SetWindowsHookEx()` function to install a low-level
keyboard hook in C++:

```cpp
HHOOK hhk = SetWindowsHookEx(WH_KEYBOARD_LL, (HOOKCB)KeyboardHookCallback, NULL, 0);
if (hhk == NULL) {
    // Handle error
}
```

In this example, `KeyboardHookCallback()` is the name of the hook proc callback function that processes the captured keyboard events. You need to define this function in your code and handle the appropriate keyboard event messages (e.g., `WM_KEYDOWN`, `WM_KEYUP`) by using the `lParam` parameter of the `KeyboardHookCallback()` function, which contains information about the
captured keystrokes.

Remember that you also need to uninstall your hook by calling the `UnhookWindowsHookEx()`
function when your keylogger is no longer running or needs to be removed from the system:

```cpp
if (hhk != NULL) {
    UnhookWindowsHookEx(hhk);
}
```



Function breakdown:
```c
HHOOK SetWindowsHookEx(
  int       idHook,
  HOOKPROC  lpfn,
  HINSTANCE hMod,
  DWORD     dwThreadId
);
```

The function return a variable of type HHOOK, which is a **Handle** to the hook procedure. 

When the hook is installed on the system, and if it is configured to listens to keyboard strokes, then the callback function "lpfn" is called each time a key is pressed. 


- idHook: Specifies the type of hook to be installed.
- lpfn: **Long pointer to a function** ,  a callback function that will be called when the specified events occur. Parameter that expects a pointer to a hook procedure. This function is user defined, but must adhere to specific signatures defined by the type of hook being set. The return type of this function depend on the idHook parameter. 
- hMod: Handel to the DLL containing the hook procedure pointed to by "lpfn".
- dwThreadId: Identifier of the thread with which the hook procedure is to be associated. If parameter is: 0; then the hook procedure is associated with all existing threads.

Draft from Gpt-4o:
```c
#include <windows.h>

HHOOK hHook = NULL;

// Hook procedure for keyboard events
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0) { // nCode >= 0 means a key event is being processed
        if (wParam == WM_KEYDOWN) {
            KBDLLHOOKSTRUCT *kbdStruct = (KBDLLHOOKSTRUCT *)lParam;
            DWORD vkCode = kbdStruct->vkCode;
            // Handle the key press (e.g., log it, modify it, etc.)
            // For demonstration, let's just output the key code
            printf("Key Pressed: %d\n", vkCode);
        }
    }
    // Call the next hook in the chain
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

int main() {
    // Install the hook
    hHook = SetWindowsHookEx(
, KeyboardProc, NULL, 0);
    if (hHook == NULL) {
        printf("Failed to install hook!\n");
        return 1;
    }

    // Keep the application running to listen for events
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Unhook the hook when done
    UnhookWindowsHookEx(hHook);

    return 0;
}
```


**Hook procedure:**
When we use SetWindowsHookExW(), one of the parameters in the function is the callback function that will be executed. This function is user defined, but always follows the same template.   

```c
LRESULT CALLBACK name_of_the_callbackfunction (int nCode, WPARAM wParam, LPARAM lParam)
```


- nCode: An int value, the hook uses it to determine how to process the message.  
- wPram: Specifies the type of keyboard event, WM_KEYDOWN etc..
- lParam: Points to a struct (KBDLLHOOKSTRUCT) that contains more info about the event.  We can use the time value in our keylogger. 

```c
typedef struct tagKBDLLHOOKSTRUCT {
    DWORD vkCode;      // Virtual key code
    DWORD scanCode;    // Hardware scan code
    DWORD flags;       // Event-injected flags
    DWORD time;        // Timestamp for the event
    ULONG_PTR dwExtraInfo; // Extra information
} KBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;
```


**Message loop:**
Processes messages sent to a application by the operating system. Each thread that creates a windows has its own message queue.  The messages in the message queue contain information about keystrokes, mouse movements and other events. 

Purpose of the message loop:
Retrieve messages from the threads message queue and dispatches them to the appropriate window procedures for handling. 

**GetMessage**(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax)

- lpMsg: Pointer to Msg struct, revives message information from the threads message queue. 
- hWnd
- wMsgFilterMin
- wMsgFilterMax


**Messages and events:** gpt-4o
### Events and Messages

1. **Events Intercepted by Hooks**:
    
    - **Low-Level Events**: Hooks can intercept low-level events, such as keystrokes or mouse movements, before they are processed by the system or any application. These events are handled by low-level hooks, like `WH_KEYBOARD_LL` and `WH_MOUSE_LL`.
    - **Hook Procedures**: When you install a hook, you provide a hook procedure (callback function) that gets called whenever the specified event occurs. For example, a keyboard hook procedure might get called whenever a key is pressed or released.
2. **Messages in the Message Queue**:
    
    - **High-Level Messages**: The message queue contains high-level messages that are sent to a window or thread by the operating system. These messages include things like `WM_KEYDOWN`, `WM_KEYUP`, `WM_MOUSEMOVE`, and many other window messages.
    - **Message Processing**: The message loop (`GetMessage`, `TranslateMessage`, `DispatchMessage`) retrieves messages from the message queue and sends them to the appropriate window procedure for processing.

### How They Relate and Interact

1. **Event Flow with Hooks**:
    
    - **Interception**: When a low-level event (e.g., a key press) occurs, the hook intercepts it before it becomes a high-level message.
    - **Processing in Hook Procedure**: The hook procedure processes the event. This can include modifying the event, logging it, or performing any other desired action.
    - **Passing to Next Hook**: The hook procedure usually calls `CallNextHookEx` to pass the event to the next hook in the chain or let the system continue processing it.
2. **Message Flow in the Message Queue**:
    
    - **Event to Message**: After the hook procedures (if any) have processed the event, it is converted into a high-level message (e.g., `WM_KEYDOWN`) and placed in the message queue of the thread that owns the window receiving the message.
    - **Message Retrieval**: The message loop retrieves these messages from the queue using `GetMessage`.
    - **Message Translation and Dispatching**: `TranslateMessage` translates virtual-key messages to character messages, and `DispatchMessage` sends the message to the window procedure for handling.

### Example Scenario: Key Press Event

1. **Key Press Event**:
    
    - A key is pressed on the keyboard.
2. **Hook Interception**:
    
    - A low-level keyboard hook (`WH_KEYBOARD_LL`) intercepts the key press event.
    - The hook procedure (`KeyboardProc`) is called with details about the key press.
    - The hook procedure can log the key press, modify it, or block it. After processing, it calls `CallNextHookEx`.
3. **Message Generation**:
    
    - After all hooks have processed the event, the system generates a `WM_KEYDOWN` message and places it in the message queue of the appropriate thread.
4. **Message Loop Processing**:
    
    - The message loop (`GetMessage`, `TranslateMessage`, `DispatchMessage`) retrieves the `WM_KEYDOWN` message from the queue.
    - `TranslateMessage` converts virtual-key messages to character messages if necessary.
    - `DispatchMessage` sends the message to the window procedure for the window that is supposed to receive the key press.
5. **Window Procedure Handling**:
    
    - The window procedure processes the `WM_KEYDOWN` message, updating the application state, UI, or triggering actions based on the key press.

### Summary

- **Events Intercepted by Hooks**: Low-level, system-wide events like key presses and mouse movements. Hooks allow you to intercept and process these events before they become high-level messages.
- **Messages in the Message Queue**: High-level messages (like `WM_KEYDOWN`) that are processed by the message loop and sent to window procedures. These messages represent processed events ready for application handling.

The message loop ensures continuous message processing, which is essential for both handling high-level messages and maintaining active hooks. Hooks and message queues work together to manage how low-level events are processed and delivered to applications.


**Virtual code and unicode:**

When we get input from the keyboard, the hook gets it in a virtual key code format. Since we want to read what has been typed as normal letters, we have to translate it to unicode. 

```
int ToUnicode(
  [in]           UINT       wVirtKey,
  [in]           UINT       wScanCode,
  [in, optional] const BYTE *lpKeyState,
  [out]          LPWSTR     pwszBuff,
  [in]           int        cchBuff,
  [in]           UINT       wFlags
);
```

- wVirtKey:
- wScanCode:
- lpKeyState:
- pwszBuff:
- cchBuff:
- wFlags:

The function return an int, which in practice is a status code of the translation: 
- value < 0: Specified vk is a dead key character. 
- value = 0: Specified vk has no translation for the current state of the keyboard. 
- value > 0: One or more UTF-16 code units where written to the buffer specified by pwszBuff. 